// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: treadstone.proto

#ifndef PROTOBUF_treadstone_2eproto__INCLUDED
#define PROTOBUF_treadstone_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace UNO {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_treadstone_2eproto();
void protobuf_AssignDesc_treadstone_2eproto();
void protobuf_ShutdownFile_treadstone_2eproto();

class LoginInfo;
class RoomInfo;
class RoomDetail;
class UserInfo;
class PlayState;
class StatusInfo;
class LoginResult;
class RoomMsg;
class CardInfo;
class DoubtInfo;
class GameMsg;
class ChatMsg;
class ScoreInfo;
class ScoreMsg;
class UNOMsg;

enum RoomDetail_RoomState {
  RoomDetail_RoomState_Wait = 41,
  RoomDetail_RoomState_Running = 42
};
bool RoomDetail_RoomState_IsValid(int value);
const RoomDetail_RoomState RoomDetail_RoomState_RoomState_MIN = RoomDetail_RoomState_Wait;
const RoomDetail_RoomState RoomDetail_RoomState_RoomState_MAX = RoomDetail_RoomState_Running;
const int RoomDetail_RoomState_RoomState_ARRAYSIZE = RoomDetail_RoomState_RoomState_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoomDetail_RoomState_descriptor();
inline const ::std::string& RoomDetail_RoomState_Name(RoomDetail_RoomState value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoomDetail_RoomState_descriptor(), value);
}
inline bool RoomDetail_RoomState_Parse(
    const ::std::string& name, RoomDetail_RoomState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoomDetail_RoomState>(
    RoomDetail_RoomState_descriptor(), name, value);
}
enum UserInfo_State {
  UserInfo_State_uno = 61,
  UserInfo_State_idle = 62,
  UserInfo_State_ready = 63
};
bool UserInfo_State_IsValid(int value);
const UserInfo_State UserInfo_State_State_MIN = UserInfo_State_uno;
const UserInfo_State UserInfo_State_State_MAX = UserInfo_State_ready;
const int UserInfo_State_State_ARRAYSIZE = UserInfo_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserInfo_State_descriptor();
inline const ::std::string& UserInfo_State_Name(UserInfo_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserInfo_State_descriptor(), value);
}
inline bool UserInfo_State_Parse(
    const ::std::string& name, UserInfo_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserInfo_State>(
    UserInfo_State_descriptor(), name, value);
}
enum StatusInfo_StatusType {
  StatusInfo_StatusType_User = 51,
  StatusInfo_StatusType_Room = 52,
  StatusInfo_StatusType_Play = 53
};
bool StatusInfo_StatusType_IsValid(int value);
const StatusInfo_StatusType StatusInfo_StatusType_StatusType_MIN = StatusInfo_StatusType_User;
const StatusInfo_StatusType StatusInfo_StatusType_StatusType_MAX = StatusInfo_StatusType_Play;
const int StatusInfo_StatusType_StatusType_ARRAYSIZE = StatusInfo_StatusType_StatusType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StatusInfo_StatusType_descriptor();
inline const ::std::string& StatusInfo_StatusType_Name(StatusInfo_StatusType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StatusInfo_StatusType_descriptor(), value);
}
inline bool StatusInfo_StatusType_Parse(
    const ::std::string& name, StatusInfo_StatusType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatusInfo_StatusType>(
    StatusInfo_StatusType_descriptor(), name, value);
}
enum RoomMsg_Type {
  RoomMsg_Type_GetList = 0,
  RoomMsg_Type_ListResult = 1,
  RoomMsg_Type_Login = 2,
  RoomMsg_Type_LoginResult = 3,
  RoomMsg_Type_Create = 4,
  RoomMsg_Type_Setting = 5
};
bool RoomMsg_Type_IsValid(int value);
const RoomMsg_Type RoomMsg_Type_Type_MIN = RoomMsg_Type_GetList;
const RoomMsg_Type RoomMsg_Type_Type_MAX = RoomMsg_Type_Setting;
const int RoomMsg_Type_Type_ARRAYSIZE = RoomMsg_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoomMsg_Type_descriptor();
inline const ::std::string& RoomMsg_Type_Name(RoomMsg_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoomMsg_Type_descriptor(), value);
}
inline bool RoomMsg_Type_Parse(
    const ::std::string& name, RoomMsg_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoomMsg_Type>(
    RoomMsg_Type_descriptor(), name, value);
}
enum GameMsg_Type {
  GameMsg_Type_PlayCard = 11,
  GameMsg_Type_PlayCardResult = 12,
  GameMsg_Type_DrawCard = 13,
  GameMsg_Type_DrawCardResult = 14,
  GameMsg_Type_UNO = 15,
  GameMsg_Type_Ready = 16,
  GameMsg_Type_Doubt = 17,
  GameMsg_Type_Status = 18,
  GameMsg_Type_Done = 19,
  GameMsg_Type_Black = 20,
  GameMsg_Type_Timeout = 21
};
bool GameMsg_Type_IsValid(int value);
const GameMsg_Type GameMsg_Type_Type_MIN = GameMsg_Type_PlayCard;
const GameMsg_Type GameMsg_Type_Type_MAX = GameMsg_Type_Timeout;
const int GameMsg_Type_Type_ARRAYSIZE = GameMsg_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameMsg_Type_descriptor();
inline const ::std::string& GameMsg_Type_Name(GameMsg_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameMsg_Type_descriptor(), value);
}
inline bool GameMsg_Type_Parse(
    const ::std::string& name, GameMsg_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameMsg_Type>(
    GameMsg_Type_descriptor(), name, value);
}
enum GameMsg_ColorInfo {
  GameMsg_ColorInfo_Shit = 31,
  GameMsg_ColorInfo_Blue = 32,
  GameMsg_ColorInfo_Green = 33,
  GameMsg_ColorInfo_Yellow = 34,
  GameMsg_ColorInfo_Red = 35
};
bool GameMsg_ColorInfo_IsValid(int value);
const GameMsg_ColorInfo GameMsg_ColorInfo_ColorInfo_MIN = GameMsg_ColorInfo_Shit;
const GameMsg_ColorInfo GameMsg_ColorInfo_ColorInfo_MAX = GameMsg_ColorInfo_Red;
const int GameMsg_ColorInfo_ColorInfo_ARRAYSIZE = GameMsg_ColorInfo_ColorInfo_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameMsg_ColorInfo_descriptor();
inline const ::std::string& GameMsg_ColorInfo_Name(GameMsg_ColorInfo value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameMsg_ColorInfo_descriptor(), value);
}
inline bool GameMsg_ColorInfo_Parse(
    const ::std::string& name, GameMsg_ColorInfo* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameMsg_ColorInfo>(
    GameMsg_ColorInfo_descriptor(), name, value);
}
enum UNOMsg_Type {
  UNOMsg_Type_Room = 91,
  UNOMsg_Type_Game = 92,
  UNOMsg_Type_Chat = 93,
  UNOMsg_Type_Error = 94,
  UNOMsg_Type_Score = 95
};
bool UNOMsg_Type_IsValid(int value);
const UNOMsg_Type UNOMsg_Type_Type_MIN = UNOMsg_Type_Room;
const UNOMsg_Type UNOMsg_Type_Type_MAX = UNOMsg_Type_Score;
const int UNOMsg_Type_Type_ARRAYSIZE = UNOMsg_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* UNOMsg_Type_descriptor();
inline const ::std::string& UNOMsg_Type_Name(UNOMsg_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    UNOMsg_Type_descriptor(), value);
}
inline bool UNOMsg_Type_Parse(
    const ::std::string& name, UNOMsg_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UNOMsg_Type>(
    UNOMsg_Type_descriptor(), name, value);
}
// ===================================================================

class LoginInfo : public ::google::protobuf::Message {
 public:
  LoginInfo();
  virtual ~LoginInfo();

  LoginInfo(const LoginInfo& from);

  inline LoginInfo& operator=(const LoginInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginInfo& default_instance();

  void Swap(LoginInfo* other);

  // implements Message ----------------------------------------------

  LoginInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginInfo& from);
  void MergeFrom(const LoginInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required int32 room_number = 2;
  inline bool has_room_number() const;
  inline void clear_room_number();
  static const int kRoomNumberFieldNumber = 2;
  inline ::google::protobuf::int32 room_number() const;
  inline void set_room_number(::google::protobuf::int32 value);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:UNO.LoginInfo)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_room_number();
  inline void clear_has_room_number();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_;
  ::std::string* password_;
  ::google::protobuf::int32 room_number_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static LoginInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoomInfo : public ::google::protobuf::Message {
 public:
  RoomInfo();
  virtual ~RoomInfo();

  RoomInfo(const RoomInfo& from);

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInfo& default_instance();

  void Swap(RoomInfo* other);

  // implements Message ----------------------------------------------

  RoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomInfo& from);
  void MergeFrom(const RoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 number = 2;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 2;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // required bool locked = 3;
  inline bool has_locked() const;
  inline void clear_locked();
  static const int kLockedFieldNumber = 3;
  inline bool locked() const;
  inline void set_locked(bool value);

  // @@protoc_insertion_point(class_scope:UNO.RoomInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_locked();
  inline void clear_has_locked();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 number_;
  bool locked_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static RoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoomDetail : public ::google::protobuf::Message {
 public:
  RoomDetail();
  virtual ~RoomDetail();

  RoomDetail(const RoomDetail& from);

  inline RoomDetail& operator=(const RoomDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomDetail& default_instance();

  void Swap(RoomDetail* other);

  // implements Message ----------------------------------------------

  RoomDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomDetail& from);
  void MergeFrom(const RoomDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomDetail_RoomState RoomState;
  static const RoomState Wait = RoomDetail_RoomState_Wait;
  static const RoomState Running = RoomDetail_RoomState_Running;
  static inline bool RoomState_IsValid(int value) {
    return RoomDetail_RoomState_IsValid(value);
  }
  static const RoomState RoomState_MIN =
    RoomDetail_RoomState_RoomState_MIN;
  static const RoomState RoomState_MAX =
    RoomDetail_RoomState_RoomState_MAX;
  static const int RoomState_ARRAYSIZE =
    RoomDetail_RoomState_RoomState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoomState_descriptor() {
    return RoomDetail_RoomState_descriptor();
  }
  static inline const ::std::string& RoomState_Name(RoomState value) {
    return RoomDetail_RoomState_Name(value);
  }
  static inline bool RoomState_Parse(const ::std::string& name,
      RoomState* value) {
    return RoomDetail_RoomState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional int32 timeout = 4;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 4;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);

  // optional .UNO.RoomDetail.RoomState state = 5;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 5;
  inline ::UNO::RoomDetail_RoomState state() const;
  inline void set_state(::UNO::RoomDetail_RoomState value);

  // @@protoc_insertion_point(class_scope:UNO.RoomDetail)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 number_;
  ::google::protobuf::int32 timeout_;
  ::std::string* password_;
  int state_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static RoomDetail* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UserInfo_State State;
  static const State uno = UserInfo_State_uno;
  static const State idle = UserInfo_State_idle;
  static const State ready = UserInfo_State_ready;
  static inline bool State_IsValid(int value) {
    return UserInfo_State_IsValid(value);
  }
  static const State State_MIN =
    UserInfo_State_State_MIN;
  static const State State_MAX =
    UserInfo_State_State_MAX;
  static const int State_ARRAYSIZE =
    UserInfo_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return UserInfo_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return UserInfo_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return UserInfo_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .UNO.UserInfo.State state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::UNO::UserInfo_State state() const;
  inline void set_state(::UNO::UserInfo_State value);

  // required int32 card_count = 4;
  inline bool has_card_count() const;
  inline void clear_card_count();
  static const int kCardCountFieldNumber = 4;
  inline ::google::protobuf::int32 card_count() const;
  inline void set_card_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UNO.UserInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_card_count();
  inline void clear_has_card_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  int state_;
  ::google::protobuf::int32 card_count_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayState : public ::google::protobuf::Message {
 public:
  PlayState();
  virtual ~PlayState();

  PlayState(const PlayState& from);

  inline PlayState& operator=(const PlayState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayState& default_instance();

  void Swap(PlayState* other);

  // implements Message ----------------------------------------------

  PlayState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayState& from);
  void MergeFrom(const PlayState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 now_card = 1;
  inline bool has_now_card() const;
  inline void clear_now_card();
  static const int kNowCardFieldNumber = 1;
  inline ::google::protobuf::int32 now_card() const;
  inline void set_now_card(::google::protobuf::int32 value);

  // required bool double_card = 5 [default = false];
  inline bool has_double_card() const;
  inline void clear_double_card();
  static const int kDoubleCardFieldNumber = 5;
  inline bool double_card() const;
  inline void set_double_card(bool value);

  // required bool intercepted = 6 [default = false];
  inline bool has_intercepted() const;
  inline void clear_intercepted();
  static const int kInterceptedFieldNumber = 6;
  inline bool intercepted() const;
  inline void set_intercepted(bool value);

  // required int32 now_turn = 2;
  inline bool has_now_turn() const;
  inline void clear_now_turn();
  static const int kNowTurnFieldNumber = 2;
  inline ::google::protobuf::int32 now_turn() const;
  inline void set_now_turn(::google::protobuf::int32 value);

  // required int32 next_turn = 3;
  inline bool has_next_turn() const;
  inline void clear_next_turn();
  static const int kNextTurnFieldNumber = 3;
  inline ::google::protobuf::int32 next_turn() const;
  inline void set_next_turn(::google::protobuf::int32 value);

  // required int32 left_card = 4;
  inline bool has_left_card() const;
  inline void clear_left_card();
  static const int kLeftCardFieldNumber = 4;
  inline ::google::protobuf::int32 left_card() const;
  inline void set_left_card(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UNO.PlayState)
 private:
  inline void set_has_now_card();
  inline void clear_has_now_card();
  inline void set_has_double_card();
  inline void clear_has_double_card();
  inline void set_has_intercepted();
  inline void clear_has_intercepted();
  inline void set_has_now_turn();
  inline void clear_has_now_turn();
  inline void set_has_next_turn();
  inline void clear_has_next_turn();
  inline void set_has_left_card();
  inline void clear_has_left_card();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 now_card_;
  bool double_card_;
  bool intercepted_;
  ::google::protobuf::int32 now_turn_;
  ::google::protobuf::int32 next_turn_;
  ::google::protobuf::int32 left_card_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static PlayState* default_instance_;
};
// -------------------------------------------------------------------

class StatusInfo : public ::google::protobuf::Message {
 public:
  StatusInfo();
  virtual ~StatusInfo();

  StatusInfo(const StatusInfo& from);

  inline StatusInfo& operator=(const StatusInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusInfo& default_instance();

  void Swap(StatusInfo* other);

  // implements Message ----------------------------------------------

  StatusInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusInfo& from);
  void MergeFrom(const StatusInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StatusInfo_StatusType StatusType;
  static const StatusType User = StatusInfo_StatusType_User;
  static const StatusType Room = StatusInfo_StatusType_Room;
  static const StatusType Play = StatusInfo_StatusType_Play;
  static inline bool StatusType_IsValid(int value) {
    return StatusInfo_StatusType_IsValid(value);
  }
  static const StatusType StatusType_MIN =
    StatusInfo_StatusType_StatusType_MIN;
  static const StatusType StatusType_MAX =
    StatusInfo_StatusType_StatusType_MAX;
  static const int StatusType_ARRAYSIZE =
    StatusInfo_StatusType_StatusType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StatusType_descriptor() {
    return StatusInfo_StatusType_descriptor();
  }
  static inline const ::std::string& StatusType_Name(StatusType value) {
    return StatusInfo_StatusType_Name(value);
  }
  static inline bool StatusType_Parse(const ::std::string& name,
      StatusType* value) {
    return StatusInfo_StatusType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .UNO.StatusInfo.StatusType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::UNO::StatusInfo_StatusType type() const;
  inline void set_type(::UNO::StatusInfo_StatusType value);

  // repeated .UNO.UserInfo user_info = 2;
  inline int user_info_size() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 2;
  inline const ::UNO::UserInfo& user_info(int index) const;
  inline ::UNO::UserInfo* mutable_user_info(int index);
  inline ::UNO::UserInfo* add_user_info();
  inline const ::google::protobuf::RepeatedPtrField< ::UNO::UserInfo >&
      user_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::UNO::UserInfo >*
      mutable_user_info();

  // optional .UNO.RoomDetail room_detail = 3;
  inline bool has_room_detail() const;
  inline void clear_room_detail();
  static const int kRoomDetailFieldNumber = 3;
  inline const ::UNO::RoomDetail& room_detail() const;
  inline ::UNO::RoomDetail* mutable_room_detail();
  inline ::UNO::RoomDetail* release_room_detail();
  inline void set_allocated_room_detail(::UNO::RoomDetail* room_detail);

  // optional .UNO.PlayState play_state = 4;
  inline bool has_play_state() const;
  inline void clear_play_state();
  static const int kPlayStateFieldNumber = 4;
  inline const ::UNO::PlayState& play_state() const;
  inline ::UNO::PlayState* mutable_play_state();
  inline ::UNO::PlayState* release_play_state();
  inline void set_allocated_play_state(::UNO::PlayState* play_state);

  // optional bool all_user_updated = 5;
  inline bool has_all_user_updated() const;
  inline void clear_all_user_updated();
  static const int kAllUserUpdatedFieldNumber = 5;
  inline bool all_user_updated() const;
  inline void set_all_user_updated(bool value);

  // @@protoc_insertion_point(class_scope:UNO.StatusInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_room_detail();
  inline void clear_has_room_detail();
  inline void set_has_play_state();
  inline void clear_has_play_state();
  inline void set_has_all_user_updated();
  inline void clear_has_all_user_updated();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::UNO::UserInfo > user_info_;
  ::UNO::RoomDetail* room_detail_;
  int type_;
  bool all_user_updated_;
  ::UNO::PlayState* play_state_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static StatusInfo* default_instance_;
};
// -------------------------------------------------------------------

class LoginResult : public ::google::protobuf::Message {
 public:
  LoginResult();
  virtual ~LoginResult();

  LoginResult(const LoginResult& from);

  inline LoginResult& operator=(const LoginResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResult& default_instance();

  void Swap(LoginResult* other);

  // implements Message ----------------------------------------------

  LoginResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResult& from);
  void MergeFrom(const LoginResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 myID = 1;
  inline bool has_myid() const;
  inline void clear_myid();
  static const int kMyIDFieldNumber = 1;
  inline ::google::protobuf::int32 myid() const;
  inline void set_myid(::google::protobuf::int32 value);

  // required .UNO.StatusInfo status_info = 2;
  inline bool has_status_info() const;
  inline void clear_status_info();
  static const int kStatusInfoFieldNumber = 2;
  inline const ::UNO::StatusInfo& status_info() const;
  inline ::UNO::StatusInfo* mutable_status_info();
  inline ::UNO::StatusInfo* release_status_info();
  inline void set_allocated_status_info(::UNO::StatusInfo* status_info);

  // @@protoc_insertion_point(class_scope:UNO.LoginResult)
 private:
  inline void set_has_myid();
  inline void clear_has_myid();
  inline void set_has_status_info();
  inline void clear_has_status_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::UNO::StatusInfo* status_info_;
  ::google::protobuf::int32 myid_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static LoginResult* default_instance_;
};
// -------------------------------------------------------------------

class RoomMsg : public ::google::protobuf::Message {
 public:
  RoomMsg();
  virtual ~RoomMsg();

  RoomMsg(const RoomMsg& from);

  inline RoomMsg& operator=(const RoomMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomMsg& default_instance();

  void Swap(RoomMsg* other);

  // implements Message ----------------------------------------------

  RoomMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomMsg& from);
  void MergeFrom(const RoomMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomMsg_Type Type;
  static const Type GetList = RoomMsg_Type_GetList;
  static const Type ListResult = RoomMsg_Type_ListResult;
  static const Type Login = RoomMsg_Type_Login;
  static const Type LoginResult = RoomMsg_Type_LoginResult;
  static const Type Create = RoomMsg_Type_Create;
  static const Type Setting = RoomMsg_Type_Setting;
  static inline bool Type_IsValid(int value) {
    return RoomMsg_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RoomMsg_Type_Type_MIN;
  static const Type Type_MAX =
    RoomMsg_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RoomMsg_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RoomMsg_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RoomMsg_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RoomMsg_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .UNO.RoomMsg.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::UNO::RoomMsg_Type type() const;
  inline void set_type(::UNO::RoomMsg_Type value);

  // optional .UNO.LoginInfo login_info = 2;
  inline bool has_login_info() const;
  inline void clear_login_info();
  static const int kLoginInfoFieldNumber = 2;
  inline const ::UNO::LoginInfo& login_info() const;
  inline ::UNO::LoginInfo* mutable_login_info();
  inline ::UNO::LoginInfo* release_login_info();
  inline void set_allocated_login_info(::UNO::LoginInfo* login_info);

  // repeated .UNO.RoomInfo room_info = 3;
  inline int room_info_size() const;
  inline void clear_room_info();
  static const int kRoomInfoFieldNumber = 3;
  inline const ::UNO::RoomInfo& room_info(int index) const;
  inline ::UNO::RoomInfo* mutable_room_info(int index);
  inline ::UNO::RoomInfo* add_room_info();
  inline const ::google::protobuf::RepeatedPtrField< ::UNO::RoomInfo >&
      room_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::UNO::RoomInfo >*
      mutable_room_info();

  // optional .UNO.LoginResult login_result = 5;
  inline bool has_login_result() const;
  inline void clear_login_result();
  static const int kLoginResultFieldNumber = 5;
  inline const ::UNO::LoginResult& login_result() const;
  inline ::UNO::LoginResult* mutable_login_result();
  inline ::UNO::LoginResult* release_login_result();
  inline void set_allocated_login_result(::UNO::LoginResult* login_result);

  // optional .UNO.RoomDetail room_detail = 6;
  inline bool has_room_detail() const;
  inline void clear_room_detail();
  static const int kRoomDetailFieldNumber = 6;
  inline const ::UNO::RoomDetail& room_detail() const;
  inline ::UNO::RoomDetail* mutable_room_detail();
  inline ::UNO::RoomDetail* release_room_detail();
  inline void set_allocated_room_detail(::UNO::RoomDetail* room_detail);

  // @@protoc_insertion_point(class_scope:UNO.RoomMsg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_login_info();
  inline void clear_has_login_info();
  inline void set_has_login_result();
  inline void clear_has_login_result();
  inline void set_has_room_detail();
  inline void clear_has_room_detail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::UNO::LoginInfo* login_info_;
  ::google::protobuf::RepeatedPtrField< ::UNO::RoomInfo > room_info_;
  ::UNO::LoginResult* login_result_;
  ::UNO::RoomDetail* room_detail_;
  int type_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static RoomMsg* default_instance_;
};
// -------------------------------------------------------------------

class CardInfo : public ::google::protobuf::Message {
 public:
  CardInfo();
  virtual ~CardInfo();

  CardInfo(const CardInfo& from);

  inline CardInfo& operator=(const CardInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CardInfo& default_instance();

  void Swap(CardInfo* other);

  // implements Message ----------------------------------------------

  CardInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CardInfo& from);
  void MergeFrom(const CardInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // repeated int32 number = 2;
  inline int number_size() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 2;
  inline ::google::protobuf::int32 number(int index) const;
  inline void set_number(int index, ::google::protobuf::int32 value);
  inline void add_number(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      number() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_number();

  // @@protoc_insertion_point(class_scope:UNO.CardInfo)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > number_;
  ::google::protobuf::int32 count_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static CardInfo* default_instance_;
};
// -------------------------------------------------------------------

class DoubtInfo : public ::google::protobuf::Message {
 public:
  DoubtInfo();
  virtual ~DoubtInfo();

  DoubtInfo(const DoubtInfo& from);

  inline DoubtInfo& operator=(const DoubtInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubtInfo& default_instance();

  void Swap(DoubtInfo* other);

  // implements Message ----------------------------------------------

  DoubtInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DoubtInfo& from);
  void MergeFrom(const DoubtInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UNO.DoubtInfo)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 user_id_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static DoubtInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameMsg : public ::google::protobuf::Message {
 public:
  GameMsg();
  virtual ~GameMsg();

  GameMsg(const GameMsg& from);

  inline GameMsg& operator=(const GameMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMsg& default_instance();

  void Swap(GameMsg* other);

  // implements Message ----------------------------------------------

  GameMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameMsg& from);
  void MergeFrom(const GameMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameMsg_Type Type;
  static const Type PlayCard = GameMsg_Type_PlayCard;
  static const Type PlayCardResult = GameMsg_Type_PlayCardResult;
  static const Type DrawCard = GameMsg_Type_DrawCard;
  static const Type DrawCardResult = GameMsg_Type_DrawCardResult;
  static const Type UNO = GameMsg_Type_UNO;
  static const Type Ready = GameMsg_Type_Ready;
  static const Type Doubt = GameMsg_Type_Doubt;
  static const Type Status = GameMsg_Type_Status;
  static const Type Done = GameMsg_Type_Done;
  static const Type Black = GameMsg_Type_Black;
  static const Type Timeout = GameMsg_Type_Timeout;
  static inline bool Type_IsValid(int value) {
    return GameMsg_Type_IsValid(value);
  }
  static const Type Type_MIN =
    GameMsg_Type_Type_MIN;
  static const Type Type_MAX =
    GameMsg_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    GameMsg_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return GameMsg_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return GameMsg_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return GameMsg_Type_Parse(name, value);
  }

  typedef GameMsg_ColorInfo ColorInfo;
  static const ColorInfo Shit = GameMsg_ColorInfo_Shit;
  static const ColorInfo Blue = GameMsg_ColorInfo_Blue;
  static const ColorInfo Green = GameMsg_ColorInfo_Green;
  static const ColorInfo Yellow = GameMsg_ColorInfo_Yellow;
  static const ColorInfo Red = GameMsg_ColorInfo_Red;
  static inline bool ColorInfo_IsValid(int value) {
    return GameMsg_ColorInfo_IsValid(value);
  }
  static const ColorInfo ColorInfo_MIN =
    GameMsg_ColorInfo_ColorInfo_MIN;
  static const ColorInfo ColorInfo_MAX =
    GameMsg_ColorInfo_ColorInfo_MAX;
  static const int ColorInfo_ARRAYSIZE =
    GameMsg_ColorInfo_ColorInfo_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ColorInfo_descriptor() {
    return GameMsg_ColorInfo_descriptor();
  }
  static inline const ::std::string& ColorInfo_Name(ColorInfo value) {
    return GameMsg_ColorInfo_Name(value);
  }
  static inline bool ColorInfo_Parse(const ::std::string& name,
      ColorInfo* value) {
    return GameMsg_ColorInfo_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .UNO.GameMsg.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::UNO::GameMsg_Type type() const;
  inline void set_type(::UNO::GameMsg_Type value);

  // optional .UNO.GameMsg.ColorInfo color_info = 2;
  inline bool has_color_info() const;
  inline void clear_color_info();
  static const int kColorInfoFieldNumber = 2;
  inline ::UNO::GameMsg_ColorInfo color_info() const;
  inline void set_color_info(::UNO::GameMsg_ColorInfo value);

  // optional .UNO.CardInfo card_info = 3;
  inline bool has_card_info() const;
  inline void clear_card_info();
  static const int kCardInfoFieldNumber = 3;
  inline const ::UNO::CardInfo& card_info() const;
  inline ::UNO::CardInfo* mutable_card_info();
  inline ::UNO::CardInfo* release_card_info();
  inline void set_allocated_card_info(::UNO::CardInfo* card_info);

  // optional .UNO.StatusInfo status_info = 4;
  inline bool has_status_info() const;
  inline void clear_status_info();
  static const int kStatusInfoFieldNumber = 4;
  inline const ::UNO::StatusInfo& status_info() const;
  inline ::UNO::StatusInfo* mutable_status_info();
  inline ::UNO::StatusInfo* release_status_info();
  inline void set_allocated_status_info(::UNO::StatusInfo* status_info);

  // optional .UNO.DoubtInfo doubt_info = 5;
  inline bool has_doubt_info() const;
  inline void clear_doubt_info();
  static const int kDoubtInfoFieldNumber = 5;
  inline const ::UNO::DoubtInfo& doubt_info() const;
  inline ::UNO::DoubtInfo* mutable_doubt_info();
  inline ::UNO::DoubtInfo* release_doubt_info();
  inline void set_allocated_doubt_info(::UNO::DoubtInfo* doubt_info);

  // @@protoc_insertion_point(class_scope:UNO.GameMsg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_color_info();
  inline void clear_has_color_info();
  inline void set_has_card_info();
  inline void clear_has_card_info();
  inline void set_has_status_info();
  inline void clear_has_status_info();
  inline void set_has_doubt_info();
  inline void clear_has_doubt_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  int color_info_;
  ::UNO::CardInfo* card_info_;
  ::UNO::StatusInfo* status_info_;
  ::UNO::DoubtInfo* doubt_info_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static GameMsg* default_instance_;
};
// -------------------------------------------------------------------

class ChatMsg : public ::google::protobuf::Message {
 public:
  ChatMsg();
  virtual ~ChatMsg();

  ChatMsg(const ChatMsg& from);

  inline ChatMsg& operator=(const ChatMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatMsg& default_instance();

  void Swap(ChatMsg* other);

  // implements Message ----------------------------------------------

  ChatMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatMsg& from);
  void MergeFrom(const ChatMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // required int32 userID = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 2;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:UNO.ChatMsg)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 time_;
  ::std::string* content_;
  ::google::protobuf::int32 userid_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static ChatMsg* default_instance_;
};
// -------------------------------------------------------------------

class ScoreInfo : public ::google::protobuf::Message {
 public:
  ScoreInfo();
  virtual ~ScoreInfo();

  ScoreInfo(const ScoreInfo& from);

  inline ScoreInfo& operator=(const ScoreInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScoreInfo& default_instance();

  void Swap(ScoreInfo* other);

  // implements Message ----------------------------------------------

  ScoreInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScoreInfo& from);
  void MergeFrom(const ScoreInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required int32 score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UNO.ScoreInfo)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 score_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static ScoreInfo* default_instance_;
};
// -------------------------------------------------------------------

class ScoreMsg : public ::google::protobuf::Message {
 public:
  ScoreMsg();
  virtual ~ScoreMsg();

  ScoreMsg(const ScoreMsg& from);

  inline ScoreMsg& operator=(const ScoreMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScoreMsg& default_instance();

  void Swap(ScoreMsg* other);

  // implements Message ----------------------------------------------

  ScoreMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScoreMsg& from);
  void MergeFrom(const ScoreMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .UNO.ScoreInfo score_info = 1;
  inline int score_info_size() const;
  inline void clear_score_info();
  static const int kScoreInfoFieldNumber = 1;
  inline const ::UNO::ScoreInfo& score_info(int index) const;
  inline ::UNO::ScoreInfo* mutable_score_info(int index);
  inline ::UNO::ScoreInfo* add_score_info();
  inline const ::google::protobuf::RepeatedPtrField< ::UNO::ScoreInfo >&
      score_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::UNO::ScoreInfo >*
      mutable_score_info();

  // @@protoc_insertion_point(class_scope:UNO.ScoreMsg)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::UNO::ScoreInfo > score_info_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static ScoreMsg* default_instance_;
};
// -------------------------------------------------------------------

class UNOMsg : public ::google::protobuf::Message {
 public:
  UNOMsg();
  virtual ~UNOMsg();

  UNOMsg(const UNOMsg& from);

  inline UNOMsg& operator=(const UNOMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UNOMsg& default_instance();

  void Swap(UNOMsg* other);

  // implements Message ----------------------------------------------

  UNOMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UNOMsg& from);
  void MergeFrom(const UNOMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UNOMsg_Type Type;
  static const Type Room = UNOMsg_Type_Room;
  static const Type Game = UNOMsg_Type_Game;
  static const Type Chat = UNOMsg_Type_Chat;
  static const Type Error = UNOMsg_Type_Error;
  static const Type Score = UNOMsg_Type_Score;
  static inline bool Type_IsValid(int value) {
    return UNOMsg_Type_IsValid(value);
  }
  static const Type Type_MIN =
    UNOMsg_Type_Type_MIN;
  static const Type Type_MAX =
    UNOMsg_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    UNOMsg_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return UNOMsg_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return UNOMsg_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return UNOMsg_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .UNO.UNOMsg.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::UNO::UNOMsg_Type type() const;
  inline void set_type(::UNO::UNOMsg_Type value);

  // required int64 sequence = 2;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  inline ::google::protobuf::int64 sequence() const;
  inline void set_sequence(::google::protobuf::int64 value);

  // optional .UNO.RoomMsg room_msg = 3;
  inline bool has_room_msg() const;
  inline void clear_room_msg();
  static const int kRoomMsgFieldNumber = 3;
  inline const ::UNO::RoomMsg& room_msg() const;
  inline ::UNO::RoomMsg* mutable_room_msg();
  inline ::UNO::RoomMsg* release_room_msg();
  inline void set_allocated_room_msg(::UNO::RoomMsg* room_msg);

  // optional .UNO.GameMsg game_msg = 4;
  inline bool has_game_msg() const;
  inline void clear_game_msg();
  static const int kGameMsgFieldNumber = 4;
  inline const ::UNO::GameMsg& game_msg() const;
  inline ::UNO::GameMsg* mutable_game_msg();
  inline ::UNO::GameMsg* release_game_msg();
  inline void set_allocated_game_msg(::UNO::GameMsg* game_msg);

  // optional .UNO.ChatMsg chat_msg = 5;
  inline bool has_chat_msg() const;
  inline void clear_chat_msg();
  static const int kChatMsgFieldNumber = 5;
  inline const ::UNO::ChatMsg& chat_msg() const;
  inline ::UNO::ChatMsg* mutable_chat_msg();
  inline ::UNO::ChatMsg* release_chat_msg();
  inline void set_allocated_chat_msg(::UNO::ChatMsg* chat_msg);

  // optional string error_msg = 6;
  inline bool has_error_msg() const;
  inline void clear_error_msg();
  static const int kErrorMsgFieldNumber = 6;
  inline const ::std::string& error_msg() const;
  inline void set_error_msg(const ::std::string& value);
  inline void set_error_msg(const char* value);
  inline void set_error_msg(const char* value, size_t size);
  inline ::std::string* mutable_error_msg();
  inline ::std::string* release_error_msg();
  inline void set_allocated_error_msg(::std::string* error_msg);

  // optional .UNO.ScoreMsg score_msg = 7;
  inline bool has_score_msg() const;
  inline void clear_score_msg();
  static const int kScoreMsgFieldNumber = 7;
  inline const ::UNO::ScoreMsg& score_msg() const;
  inline ::UNO::ScoreMsg* mutable_score_msg();
  inline ::UNO::ScoreMsg* release_score_msg();
  inline void set_allocated_score_msg(::UNO::ScoreMsg* score_msg);

  // @@protoc_insertion_point(class_scope:UNO.UNOMsg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_room_msg();
  inline void clear_has_room_msg();
  inline void set_has_game_msg();
  inline void clear_has_game_msg();
  inline void set_has_chat_msg();
  inline void clear_has_chat_msg();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();
  inline void set_has_score_msg();
  inline void clear_has_score_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 sequence_;
  ::UNO::RoomMsg* room_msg_;
  ::UNO::GameMsg* game_msg_;
  ::UNO::ChatMsg* chat_msg_;
  ::std::string* error_msg_;
  ::UNO::ScoreMsg* score_msg_;
  int type_;
  friend void  protobuf_AddDesc_treadstone_2eproto();
  friend void protobuf_AssignDesc_treadstone_2eproto();
  friend void protobuf_ShutdownFile_treadstone_2eproto();

  void InitAsDefaultInstance();
  static UNOMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginInfo

// required string user = 1;
inline bool LoginInfo::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginInfo::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginInfo::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& LoginInfo::user() const {
  // @@protoc_insertion_point(field_get:UNO.LoginInfo.user)
  return *user_;
}
inline void LoginInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:UNO.LoginInfo.user)
}
inline void LoginInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:UNO.LoginInfo.user)
}
inline void LoginInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UNO.LoginInfo.user)
}
inline ::std::string* LoginInfo::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UNO.LoginInfo.user)
  return user_;
}
inline ::std::string* LoginInfo::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginInfo::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.LoginInfo.user)
}

// required int32 room_number = 2;
inline bool LoginInfo::has_room_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginInfo::set_has_room_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginInfo::clear_has_room_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginInfo::clear_room_number() {
  room_number_ = 0;
  clear_has_room_number();
}
inline ::google::protobuf::int32 LoginInfo::room_number() const {
  // @@protoc_insertion_point(field_get:UNO.LoginInfo.room_number)
  return room_number_;
}
inline void LoginInfo::set_room_number(::google::protobuf::int32 value) {
  set_has_room_number();
  room_number_ = value;
  // @@protoc_insertion_point(field_set:UNO.LoginInfo.room_number)
}

// optional string password = 3;
inline bool LoginInfo::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginInfo::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginInfo::password() const {
  // @@protoc_insertion_point(field_get:UNO.LoginInfo.password)
  return *password_;
}
inline void LoginInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:UNO.LoginInfo.password)
}
inline void LoginInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:UNO.LoginInfo.password)
}
inline void LoginInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UNO.LoginInfo.password)
}
inline ::std::string* LoginInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UNO.LoginInfo.password)
  return password_;
}
inline ::std::string* LoginInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginInfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.LoginInfo.password)
}

// -------------------------------------------------------------------

// RoomInfo

// required string name = 1;
inline bool RoomInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RoomInfo::name() const {
  // @@protoc_insertion_point(field_get:UNO.RoomInfo.name)
  return *name_;
}
inline void RoomInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:UNO.RoomInfo.name)
}
inline void RoomInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:UNO.RoomInfo.name)
}
inline void RoomInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UNO.RoomInfo.name)
}
inline ::std::string* RoomInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UNO.RoomInfo.name)
  return name_;
}
inline ::std::string* RoomInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RoomInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.RoomInfo.name)
}

// required int32 number = 2;
inline bool RoomInfo::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInfo::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInfo::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInfo::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 RoomInfo::number() const {
  // @@protoc_insertion_point(field_get:UNO.RoomInfo.number)
  return number_;
}
inline void RoomInfo::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:UNO.RoomInfo.number)
}

// required bool locked = 3;
inline bool RoomInfo::has_locked() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomInfo::set_has_locked() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomInfo::clear_has_locked() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomInfo::clear_locked() {
  locked_ = false;
  clear_has_locked();
}
inline bool RoomInfo::locked() const {
  // @@protoc_insertion_point(field_get:UNO.RoomInfo.locked)
  return locked_;
}
inline void RoomInfo::set_locked(bool value) {
  set_has_locked();
  locked_ = value;
  // @@protoc_insertion_point(field_set:UNO.RoomInfo.locked)
}

// -------------------------------------------------------------------

// RoomDetail

// required int32 number = 1;
inline bool RoomDetail::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomDetail::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomDetail::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomDetail::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 RoomDetail::number() const {
  // @@protoc_insertion_point(field_get:UNO.RoomDetail.number)
  return number_;
}
inline void RoomDetail::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:UNO.RoomDetail.number)
}

// optional string name = 2;
inline bool RoomDetail::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomDetail::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomDetail::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomDetail::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RoomDetail::name() const {
  // @@protoc_insertion_point(field_get:UNO.RoomDetail.name)
  return *name_;
}
inline void RoomDetail::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:UNO.RoomDetail.name)
}
inline void RoomDetail::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:UNO.RoomDetail.name)
}
inline void RoomDetail::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UNO.RoomDetail.name)
}
inline ::std::string* RoomDetail::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UNO.RoomDetail.name)
  return name_;
}
inline ::std::string* RoomDetail::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RoomDetail::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.RoomDetail.name)
}

// optional string password = 3;
inline bool RoomDetail::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomDetail::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomDetail::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomDetail::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& RoomDetail::password() const {
  // @@protoc_insertion_point(field_get:UNO.RoomDetail.password)
  return *password_;
}
inline void RoomDetail::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:UNO.RoomDetail.password)
}
inline void RoomDetail::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:UNO.RoomDetail.password)
}
inline void RoomDetail::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UNO.RoomDetail.password)
}
inline ::std::string* RoomDetail::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UNO.RoomDetail.password)
  return password_;
}
inline ::std::string* RoomDetail::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RoomDetail::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.RoomDetail.password)
}

// optional int32 timeout = 4;
inline bool RoomDetail::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomDetail::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomDetail::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomDetail::clear_timeout() {
  timeout_ = 0;
  clear_has_timeout();
}
inline ::google::protobuf::int32 RoomDetail::timeout() const {
  // @@protoc_insertion_point(field_get:UNO.RoomDetail.timeout)
  return timeout_;
}
inline void RoomDetail::set_timeout(::google::protobuf::int32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:UNO.RoomDetail.timeout)
}

// optional .UNO.RoomDetail.RoomState state = 5;
inline bool RoomDetail::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomDetail::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomDetail::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomDetail::clear_state() {
  state_ = 41;
  clear_has_state();
}
inline ::UNO::RoomDetail_RoomState RoomDetail::state() const {
  // @@protoc_insertion_point(field_get:UNO.RoomDetail.state)
  return static_cast< ::UNO::RoomDetail_RoomState >(state_);
}
inline void RoomDetail::set_state(::UNO::RoomDetail_RoomState value) {
  assert(::UNO::RoomDetail_RoomState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:UNO.RoomDetail.state)
}

// -------------------------------------------------------------------

// UserInfo

// required int32 ID = 1;
inline bool UserInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UserInfo::id() const {
  // @@protoc_insertion_point(field_get:UNO.UserInfo.ID)
  return id_;
}
inline void UserInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:UNO.UserInfo.ID)
}

// required string name = 2;
inline bool UserInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserInfo::name() const {
  // @@protoc_insertion_point(field_get:UNO.UserInfo.name)
  return *name_;
}
inline void UserInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:UNO.UserInfo.name)
}
inline void UserInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:UNO.UserInfo.name)
}
inline void UserInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UNO.UserInfo.name)
}
inline ::std::string* UserInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UNO.UserInfo.name)
  return name_;
}
inline ::std::string* UserInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.UserInfo.name)
}

// required .UNO.UserInfo.State state = 3;
inline bool UserInfo::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_state() {
  state_ = 61;
  clear_has_state();
}
inline ::UNO::UserInfo_State UserInfo::state() const {
  // @@protoc_insertion_point(field_get:UNO.UserInfo.state)
  return static_cast< ::UNO::UserInfo_State >(state_);
}
inline void UserInfo::set_state(::UNO::UserInfo_State value) {
  assert(::UNO::UserInfo_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:UNO.UserInfo.state)
}

// required int32 card_count = 4;
inline bool UserInfo::has_card_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_card_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_card_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_card_count() {
  card_count_ = 0;
  clear_has_card_count();
}
inline ::google::protobuf::int32 UserInfo::card_count() const {
  // @@protoc_insertion_point(field_get:UNO.UserInfo.card_count)
  return card_count_;
}
inline void UserInfo::set_card_count(::google::protobuf::int32 value) {
  set_has_card_count();
  card_count_ = value;
  // @@protoc_insertion_point(field_set:UNO.UserInfo.card_count)
}

// -------------------------------------------------------------------

// PlayState

// required int32 now_card = 1;
inline bool PlayState::has_now_card() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayState::set_has_now_card() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayState::clear_has_now_card() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayState::clear_now_card() {
  now_card_ = 0;
  clear_has_now_card();
}
inline ::google::protobuf::int32 PlayState::now_card() const {
  // @@protoc_insertion_point(field_get:UNO.PlayState.now_card)
  return now_card_;
}
inline void PlayState::set_now_card(::google::protobuf::int32 value) {
  set_has_now_card();
  now_card_ = value;
  // @@protoc_insertion_point(field_set:UNO.PlayState.now_card)
}

// required bool double_card = 5 [default = false];
inline bool PlayState::has_double_card() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayState::set_has_double_card() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayState::clear_has_double_card() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayState::clear_double_card() {
  double_card_ = false;
  clear_has_double_card();
}
inline bool PlayState::double_card() const {
  // @@protoc_insertion_point(field_get:UNO.PlayState.double_card)
  return double_card_;
}
inline void PlayState::set_double_card(bool value) {
  set_has_double_card();
  double_card_ = value;
  // @@protoc_insertion_point(field_set:UNO.PlayState.double_card)
}

// required bool intercepted = 6 [default = false];
inline bool PlayState::has_intercepted() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayState::set_has_intercepted() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayState::clear_has_intercepted() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayState::clear_intercepted() {
  intercepted_ = false;
  clear_has_intercepted();
}
inline bool PlayState::intercepted() const {
  // @@protoc_insertion_point(field_get:UNO.PlayState.intercepted)
  return intercepted_;
}
inline void PlayState::set_intercepted(bool value) {
  set_has_intercepted();
  intercepted_ = value;
  // @@protoc_insertion_point(field_set:UNO.PlayState.intercepted)
}

// required int32 now_turn = 2;
inline bool PlayState::has_now_turn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayState::set_has_now_turn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayState::clear_has_now_turn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayState::clear_now_turn() {
  now_turn_ = 0;
  clear_has_now_turn();
}
inline ::google::protobuf::int32 PlayState::now_turn() const {
  // @@protoc_insertion_point(field_get:UNO.PlayState.now_turn)
  return now_turn_;
}
inline void PlayState::set_now_turn(::google::protobuf::int32 value) {
  set_has_now_turn();
  now_turn_ = value;
  // @@protoc_insertion_point(field_set:UNO.PlayState.now_turn)
}

// required int32 next_turn = 3;
inline bool PlayState::has_next_turn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayState::set_has_next_turn() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayState::clear_has_next_turn() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayState::clear_next_turn() {
  next_turn_ = 0;
  clear_has_next_turn();
}
inline ::google::protobuf::int32 PlayState::next_turn() const {
  // @@protoc_insertion_point(field_get:UNO.PlayState.next_turn)
  return next_turn_;
}
inline void PlayState::set_next_turn(::google::protobuf::int32 value) {
  set_has_next_turn();
  next_turn_ = value;
  // @@protoc_insertion_point(field_set:UNO.PlayState.next_turn)
}

// required int32 left_card = 4;
inline bool PlayState::has_left_card() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayState::set_has_left_card() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayState::clear_has_left_card() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayState::clear_left_card() {
  left_card_ = 0;
  clear_has_left_card();
}
inline ::google::protobuf::int32 PlayState::left_card() const {
  // @@protoc_insertion_point(field_get:UNO.PlayState.left_card)
  return left_card_;
}
inline void PlayState::set_left_card(::google::protobuf::int32 value) {
  set_has_left_card();
  left_card_ = value;
  // @@protoc_insertion_point(field_set:UNO.PlayState.left_card)
}

// -------------------------------------------------------------------

// StatusInfo

// required .UNO.StatusInfo.StatusType type = 1;
inline bool StatusInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusInfo::clear_type() {
  type_ = 51;
  clear_has_type();
}
inline ::UNO::StatusInfo_StatusType StatusInfo::type() const {
  // @@protoc_insertion_point(field_get:UNO.StatusInfo.type)
  return static_cast< ::UNO::StatusInfo_StatusType >(type_);
}
inline void StatusInfo::set_type(::UNO::StatusInfo_StatusType value) {
  assert(::UNO::StatusInfo_StatusType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:UNO.StatusInfo.type)
}

// repeated .UNO.UserInfo user_info = 2;
inline int StatusInfo::user_info_size() const {
  return user_info_.size();
}
inline void StatusInfo::clear_user_info() {
  user_info_.Clear();
}
inline const ::UNO::UserInfo& StatusInfo::user_info(int index) const {
  // @@protoc_insertion_point(field_get:UNO.StatusInfo.user_info)
  return user_info_.Get(index);
}
inline ::UNO::UserInfo* StatusInfo::mutable_user_info(int index) {
  // @@protoc_insertion_point(field_mutable:UNO.StatusInfo.user_info)
  return user_info_.Mutable(index);
}
inline ::UNO::UserInfo* StatusInfo::add_user_info() {
  // @@protoc_insertion_point(field_add:UNO.StatusInfo.user_info)
  return user_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UNO::UserInfo >&
StatusInfo::user_info() const {
  // @@protoc_insertion_point(field_list:UNO.StatusInfo.user_info)
  return user_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::UNO::UserInfo >*
StatusInfo::mutable_user_info() {
  // @@protoc_insertion_point(field_mutable_list:UNO.StatusInfo.user_info)
  return &user_info_;
}

// optional .UNO.RoomDetail room_detail = 3;
inline bool StatusInfo::has_room_detail() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatusInfo::set_has_room_detail() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatusInfo::clear_has_room_detail() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatusInfo::clear_room_detail() {
  if (room_detail_ != NULL) room_detail_->::UNO::RoomDetail::Clear();
  clear_has_room_detail();
}
inline const ::UNO::RoomDetail& StatusInfo::room_detail() const {
  // @@protoc_insertion_point(field_get:UNO.StatusInfo.room_detail)
  return room_detail_ != NULL ? *room_detail_ : *default_instance_->room_detail_;
}
inline ::UNO::RoomDetail* StatusInfo::mutable_room_detail() {
  set_has_room_detail();
  if (room_detail_ == NULL) room_detail_ = new ::UNO::RoomDetail;
  // @@protoc_insertion_point(field_mutable:UNO.StatusInfo.room_detail)
  return room_detail_;
}
inline ::UNO::RoomDetail* StatusInfo::release_room_detail() {
  clear_has_room_detail();
  ::UNO::RoomDetail* temp = room_detail_;
  room_detail_ = NULL;
  return temp;
}
inline void StatusInfo::set_allocated_room_detail(::UNO::RoomDetail* room_detail) {
  delete room_detail_;
  room_detail_ = room_detail;
  if (room_detail) {
    set_has_room_detail();
  } else {
    clear_has_room_detail();
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.StatusInfo.room_detail)
}

// optional .UNO.PlayState play_state = 4;
inline bool StatusInfo::has_play_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StatusInfo::set_has_play_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StatusInfo::clear_has_play_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StatusInfo::clear_play_state() {
  if (play_state_ != NULL) play_state_->::UNO::PlayState::Clear();
  clear_has_play_state();
}
inline const ::UNO::PlayState& StatusInfo::play_state() const {
  // @@protoc_insertion_point(field_get:UNO.StatusInfo.play_state)
  return play_state_ != NULL ? *play_state_ : *default_instance_->play_state_;
}
inline ::UNO::PlayState* StatusInfo::mutable_play_state() {
  set_has_play_state();
  if (play_state_ == NULL) play_state_ = new ::UNO::PlayState;
  // @@protoc_insertion_point(field_mutable:UNO.StatusInfo.play_state)
  return play_state_;
}
inline ::UNO::PlayState* StatusInfo::release_play_state() {
  clear_has_play_state();
  ::UNO::PlayState* temp = play_state_;
  play_state_ = NULL;
  return temp;
}
inline void StatusInfo::set_allocated_play_state(::UNO::PlayState* play_state) {
  delete play_state_;
  play_state_ = play_state;
  if (play_state) {
    set_has_play_state();
  } else {
    clear_has_play_state();
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.StatusInfo.play_state)
}

// optional bool all_user_updated = 5;
inline bool StatusInfo::has_all_user_updated() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StatusInfo::set_has_all_user_updated() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StatusInfo::clear_has_all_user_updated() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StatusInfo::clear_all_user_updated() {
  all_user_updated_ = false;
  clear_has_all_user_updated();
}
inline bool StatusInfo::all_user_updated() const {
  // @@protoc_insertion_point(field_get:UNO.StatusInfo.all_user_updated)
  return all_user_updated_;
}
inline void StatusInfo::set_all_user_updated(bool value) {
  set_has_all_user_updated();
  all_user_updated_ = value;
  // @@protoc_insertion_point(field_set:UNO.StatusInfo.all_user_updated)
}

// -------------------------------------------------------------------

// LoginResult

// required int32 myID = 1;
inline bool LoginResult::has_myid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResult::set_has_myid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResult::clear_has_myid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResult::clear_myid() {
  myid_ = 0;
  clear_has_myid();
}
inline ::google::protobuf::int32 LoginResult::myid() const {
  // @@protoc_insertion_point(field_get:UNO.LoginResult.myID)
  return myid_;
}
inline void LoginResult::set_myid(::google::protobuf::int32 value) {
  set_has_myid();
  myid_ = value;
  // @@protoc_insertion_point(field_set:UNO.LoginResult.myID)
}

// required .UNO.StatusInfo status_info = 2;
inline bool LoginResult::has_status_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResult::set_has_status_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResult::clear_has_status_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResult::clear_status_info() {
  if (status_info_ != NULL) status_info_->::UNO::StatusInfo::Clear();
  clear_has_status_info();
}
inline const ::UNO::StatusInfo& LoginResult::status_info() const {
  // @@protoc_insertion_point(field_get:UNO.LoginResult.status_info)
  return status_info_ != NULL ? *status_info_ : *default_instance_->status_info_;
}
inline ::UNO::StatusInfo* LoginResult::mutable_status_info() {
  set_has_status_info();
  if (status_info_ == NULL) status_info_ = new ::UNO::StatusInfo;
  // @@protoc_insertion_point(field_mutable:UNO.LoginResult.status_info)
  return status_info_;
}
inline ::UNO::StatusInfo* LoginResult::release_status_info() {
  clear_has_status_info();
  ::UNO::StatusInfo* temp = status_info_;
  status_info_ = NULL;
  return temp;
}
inline void LoginResult::set_allocated_status_info(::UNO::StatusInfo* status_info) {
  delete status_info_;
  status_info_ = status_info;
  if (status_info) {
    set_has_status_info();
  } else {
    clear_has_status_info();
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.LoginResult.status_info)
}

// -------------------------------------------------------------------

// RoomMsg

// required .UNO.RoomMsg.Type type = 1;
inline bool RoomMsg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomMsg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomMsg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::UNO::RoomMsg_Type RoomMsg::type() const {
  // @@protoc_insertion_point(field_get:UNO.RoomMsg.type)
  return static_cast< ::UNO::RoomMsg_Type >(type_);
}
inline void RoomMsg::set_type(::UNO::RoomMsg_Type value) {
  assert(::UNO::RoomMsg_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:UNO.RoomMsg.type)
}

// optional .UNO.LoginInfo login_info = 2;
inline bool RoomMsg::has_login_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomMsg::set_has_login_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomMsg::clear_has_login_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomMsg::clear_login_info() {
  if (login_info_ != NULL) login_info_->::UNO::LoginInfo::Clear();
  clear_has_login_info();
}
inline const ::UNO::LoginInfo& RoomMsg::login_info() const {
  // @@protoc_insertion_point(field_get:UNO.RoomMsg.login_info)
  return login_info_ != NULL ? *login_info_ : *default_instance_->login_info_;
}
inline ::UNO::LoginInfo* RoomMsg::mutable_login_info() {
  set_has_login_info();
  if (login_info_ == NULL) login_info_ = new ::UNO::LoginInfo;
  // @@protoc_insertion_point(field_mutable:UNO.RoomMsg.login_info)
  return login_info_;
}
inline ::UNO::LoginInfo* RoomMsg::release_login_info() {
  clear_has_login_info();
  ::UNO::LoginInfo* temp = login_info_;
  login_info_ = NULL;
  return temp;
}
inline void RoomMsg::set_allocated_login_info(::UNO::LoginInfo* login_info) {
  delete login_info_;
  login_info_ = login_info;
  if (login_info) {
    set_has_login_info();
  } else {
    clear_has_login_info();
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.RoomMsg.login_info)
}

// repeated .UNO.RoomInfo room_info = 3;
inline int RoomMsg::room_info_size() const {
  return room_info_.size();
}
inline void RoomMsg::clear_room_info() {
  room_info_.Clear();
}
inline const ::UNO::RoomInfo& RoomMsg::room_info(int index) const {
  // @@protoc_insertion_point(field_get:UNO.RoomMsg.room_info)
  return room_info_.Get(index);
}
inline ::UNO::RoomInfo* RoomMsg::mutable_room_info(int index) {
  // @@protoc_insertion_point(field_mutable:UNO.RoomMsg.room_info)
  return room_info_.Mutable(index);
}
inline ::UNO::RoomInfo* RoomMsg::add_room_info() {
  // @@protoc_insertion_point(field_add:UNO.RoomMsg.room_info)
  return room_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UNO::RoomInfo >&
RoomMsg::room_info() const {
  // @@protoc_insertion_point(field_list:UNO.RoomMsg.room_info)
  return room_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::UNO::RoomInfo >*
RoomMsg::mutable_room_info() {
  // @@protoc_insertion_point(field_mutable_list:UNO.RoomMsg.room_info)
  return &room_info_;
}

// optional .UNO.LoginResult login_result = 5;
inline bool RoomMsg::has_login_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomMsg::set_has_login_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomMsg::clear_has_login_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomMsg::clear_login_result() {
  if (login_result_ != NULL) login_result_->::UNO::LoginResult::Clear();
  clear_has_login_result();
}
inline const ::UNO::LoginResult& RoomMsg::login_result() const {
  // @@protoc_insertion_point(field_get:UNO.RoomMsg.login_result)
  return login_result_ != NULL ? *login_result_ : *default_instance_->login_result_;
}
inline ::UNO::LoginResult* RoomMsg::mutable_login_result() {
  set_has_login_result();
  if (login_result_ == NULL) login_result_ = new ::UNO::LoginResult;
  // @@protoc_insertion_point(field_mutable:UNO.RoomMsg.login_result)
  return login_result_;
}
inline ::UNO::LoginResult* RoomMsg::release_login_result() {
  clear_has_login_result();
  ::UNO::LoginResult* temp = login_result_;
  login_result_ = NULL;
  return temp;
}
inline void RoomMsg::set_allocated_login_result(::UNO::LoginResult* login_result) {
  delete login_result_;
  login_result_ = login_result;
  if (login_result) {
    set_has_login_result();
  } else {
    clear_has_login_result();
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.RoomMsg.login_result)
}

// optional .UNO.RoomDetail room_detail = 6;
inline bool RoomMsg::has_room_detail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomMsg::set_has_room_detail() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomMsg::clear_has_room_detail() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomMsg::clear_room_detail() {
  if (room_detail_ != NULL) room_detail_->::UNO::RoomDetail::Clear();
  clear_has_room_detail();
}
inline const ::UNO::RoomDetail& RoomMsg::room_detail() const {
  // @@protoc_insertion_point(field_get:UNO.RoomMsg.room_detail)
  return room_detail_ != NULL ? *room_detail_ : *default_instance_->room_detail_;
}
inline ::UNO::RoomDetail* RoomMsg::mutable_room_detail() {
  set_has_room_detail();
  if (room_detail_ == NULL) room_detail_ = new ::UNO::RoomDetail;
  // @@protoc_insertion_point(field_mutable:UNO.RoomMsg.room_detail)
  return room_detail_;
}
inline ::UNO::RoomDetail* RoomMsg::release_room_detail() {
  clear_has_room_detail();
  ::UNO::RoomDetail* temp = room_detail_;
  room_detail_ = NULL;
  return temp;
}
inline void RoomMsg::set_allocated_room_detail(::UNO::RoomDetail* room_detail) {
  delete room_detail_;
  room_detail_ = room_detail;
  if (room_detail) {
    set_has_room_detail();
  } else {
    clear_has_room_detail();
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.RoomMsg.room_detail)
}

// -------------------------------------------------------------------

// CardInfo

// required int32 count = 1;
inline bool CardInfo::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CardInfo::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CardInfo::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CardInfo::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 CardInfo::count() const {
  // @@protoc_insertion_point(field_get:UNO.CardInfo.count)
  return count_;
}
inline void CardInfo::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:UNO.CardInfo.count)
}

// repeated int32 number = 2;
inline int CardInfo::number_size() const {
  return number_.size();
}
inline void CardInfo::clear_number() {
  number_.Clear();
}
inline ::google::protobuf::int32 CardInfo::number(int index) const {
  // @@protoc_insertion_point(field_get:UNO.CardInfo.number)
  return number_.Get(index);
}
inline void CardInfo::set_number(int index, ::google::protobuf::int32 value) {
  number_.Set(index, value);
  // @@protoc_insertion_point(field_set:UNO.CardInfo.number)
}
inline void CardInfo::add_number(::google::protobuf::int32 value) {
  number_.Add(value);
  // @@protoc_insertion_point(field_add:UNO.CardInfo.number)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CardInfo::number() const {
  // @@protoc_insertion_point(field_list:UNO.CardInfo.number)
  return number_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CardInfo::mutable_number() {
  // @@protoc_insertion_point(field_mutable_list:UNO.CardInfo.number)
  return &number_;
}

// -------------------------------------------------------------------

// DoubtInfo

// required int32 user_id = 1;
inline bool DoubtInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoubtInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DoubtInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DoubtInfo::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 DoubtInfo::user_id() const {
  // @@protoc_insertion_point(field_get:UNO.DoubtInfo.user_id)
  return user_id_;
}
inline void DoubtInfo::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:UNO.DoubtInfo.user_id)
}

// -------------------------------------------------------------------

// GameMsg

// required .UNO.GameMsg.Type type = 1;
inline bool GameMsg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameMsg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameMsg::clear_type() {
  type_ = 11;
  clear_has_type();
}
inline ::UNO::GameMsg_Type GameMsg::type() const {
  // @@protoc_insertion_point(field_get:UNO.GameMsg.type)
  return static_cast< ::UNO::GameMsg_Type >(type_);
}
inline void GameMsg::set_type(::UNO::GameMsg_Type value) {
  assert(::UNO::GameMsg_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:UNO.GameMsg.type)
}

// optional .UNO.GameMsg.ColorInfo color_info = 2;
inline bool GameMsg::has_color_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameMsg::set_has_color_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameMsg::clear_has_color_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameMsg::clear_color_info() {
  color_info_ = 31;
  clear_has_color_info();
}
inline ::UNO::GameMsg_ColorInfo GameMsg::color_info() const {
  // @@protoc_insertion_point(field_get:UNO.GameMsg.color_info)
  return static_cast< ::UNO::GameMsg_ColorInfo >(color_info_);
}
inline void GameMsg::set_color_info(::UNO::GameMsg_ColorInfo value) {
  assert(::UNO::GameMsg_ColorInfo_IsValid(value));
  set_has_color_info();
  color_info_ = value;
  // @@protoc_insertion_point(field_set:UNO.GameMsg.color_info)
}

// optional .UNO.CardInfo card_info = 3;
inline bool GameMsg::has_card_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameMsg::set_has_card_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameMsg::clear_has_card_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameMsg::clear_card_info() {
  if (card_info_ != NULL) card_info_->::UNO::CardInfo::Clear();
  clear_has_card_info();
}
inline const ::UNO::CardInfo& GameMsg::card_info() const {
  // @@protoc_insertion_point(field_get:UNO.GameMsg.card_info)
  return card_info_ != NULL ? *card_info_ : *default_instance_->card_info_;
}
inline ::UNO::CardInfo* GameMsg::mutable_card_info() {
  set_has_card_info();
  if (card_info_ == NULL) card_info_ = new ::UNO::CardInfo;
  // @@protoc_insertion_point(field_mutable:UNO.GameMsg.card_info)
  return card_info_;
}
inline ::UNO::CardInfo* GameMsg::release_card_info() {
  clear_has_card_info();
  ::UNO::CardInfo* temp = card_info_;
  card_info_ = NULL;
  return temp;
}
inline void GameMsg::set_allocated_card_info(::UNO::CardInfo* card_info) {
  delete card_info_;
  card_info_ = card_info;
  if (card_info) {
    set_has_card_info();
  } else {
    clear_has_card_info();
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.GameMsg.card_info)
}

// optional .UNO.StatusInfo status_info = 4;
inline bool GameMsg::has_status_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameMsg::set_has_status_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameMsg::clear_has_status_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameMsg::clear_status_info() {
  if (status_info_ != NULL) status_info_->::UNO::StatusInfo::Clear();
  clear_has_status_info();
}
inline const ::UNO::StatusInfo& GameMsg::status_info() const {
  // @@protoc_insertion_point(field_get:UNO.GameMsg.status_info)
  return status_info_ != NULL ? *status_info_ : *default_instance_->status_info_;
}
inline ::UNO::StatusInfo* GameMsg::mutable_status_info() {
  set_has_status_info();
  if (status_info_ == NULL) status_info_ = new ::UNO::StatusInfo;
  // @@protoc_insertion_point(field_mutable:UNO.GameMsg.status_info)
  return status_info_;
}
inline ::UNO::StatusInfo* GameMsg::release_status_info() {
  clear_has_status_info();
  ::UNO::StatusInfo* temp = status_info_;
  status_info_ = NULL;
  return temp;
}
inline void GameMsg::set_allocated_status_info(::UNO::StatusInfo* status_info) {
  delete status_info_;
  status_info_ = status_info;
  if (status_info) {
    set_has_status_info();
  } else {
    clear_has_status_info();
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.GameMsg.status_info)
}

// optional .UNO.DoubtInfo doubt_info = 5;
inline bool GameMsg::has_doubt_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameMsg::set_has_doubt_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameMsg::clear_has_doubt_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameMsg::clear_doubt_info() {
  if (doubt_info_ != NULL) doubt_info_->::UNO::DoubtInfo::Clear();
  clear_has_doubt_info();
}
inline const ::UNO::DoubtInfo& GameMsg::doubt_info() const {
  // @@protoc_insertion_point(field_get:UNO.GameMsg.doubt_info)
  return doubt_info_ != NULL ? *doubt_info_ : *default_instance_->doubt_info_;
}
inline ::UNO::DoubtInfo* GameMsg::mutable_doubt_info() {
  set_has_doubt_info();
  if (doubt_info_ == NULL) doubt_info_ = new ::UNO::DoubtInfo;
  // @@protoc_insertion_point(field_mutable:UNO.GameMsg.doubt_info)
  return doubt_info_;
}
inline ::UNO::DoubtInfo* GameMsg::release_doubt_info() {
  clear_has_doubt_info();
  ::UNO::DoubtInfo* temp = doubt_info_;
  doubt_info_ = NULL;
  return temp;
}
inline void GameMsg::set_allocated_doubt_info(::UNO::DoubtInfo* doubt_info) {
  delete doubt_info_;
  doubt_info_ = doubt_info;
  if (doubt_info) {
    set_has_doubt_info();
  } else {
    clear_has_doubt_info();
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.GameMsg.doubt_info)
}

// -------------------------------------------------------------------

// ChatMsg

// required int64 time = 1;
inline bool ChatMsg::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatMsg::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatMsg::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatMsg::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 ChatMsg::time() const {
  // @@protoc_insertion_point(field_get:UNO.ChatMsg.time)
  return time_;
}
inline void ChatMsg::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:UNO.ChatMsg.time)
}

// required int32 userID = 2;
inline bool ChatMsg::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatMsg::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatMsg::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatMsg::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 ChatMsg::userid() const {
  // @@protoc_insertion_point(field_get:UNO.ChatMsg.userID)
  return userid_;
}
inline void ChatMsg::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:UNO.ChatMsg.userID)
}

// required string content = 3;
inline bool ChatMsg::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatMsg::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatMsg::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatMsg::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& ChatMsg::content() const {
  // @@protoc_insertion_point(field_get:UNO.ChatMsg.content)
  return *content_;
}
inline void ChatMsg::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:UNO.ChatMsg.content)
}
inline void ChatMsg::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:UNO.ChatMsg.content)
}
inline void ChatMsg::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UNO.ChatMsg.content)
}
inline ::std::string* ChatMsg::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UNO.ChatMsg.content)
  return content_;
}
inline ::std::string* ChatMsg::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatMsg::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.ChatMsg.content)
}

// -------------------------------------------------------------------

// ScoreInfo

// required int32 userID = 1;
inline bool ScoreInfo::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScoreInfo::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScoreInfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScoreInfo::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 ScoreInfo::userid() const {
  // @@protoc_insertion_point(field_get:UNO.ScoreInfo.userID)
  return userid_;
}
inline void ScoreInfo::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:UNO.ScoreInfo.userID)
}

// required int32 score = 2;
inline bool ScoreInfo::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScoreInfo::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScoreInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScoreInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 ScoreInfo::score() const {
  // @@protoc_insertion_point(field_get:UNO.ScoreInfo.score)
  return score_;
}
inline void ScoreInfo::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:UNO.ScoreInfo.score)
}

// -------------------------------------------------------------------

// ScoreMsg

// repeated .UNO.ScoreInfo score_info = 1;
inline int ScoreMsg::score_info_size() const {
  return score_info_.size();
}
inline void ScoreMsg::clear_score_info() {
  score_info_.Clear();
}
inline const ::UNO::ScoreInfo& ScoreMsg::score_info(int index) const {
  // @@protoc_insertion_point(field_get:UNO.ScoreMsg.score_info)
  return score_info_.Get(index);
}
inline ::UNO::ScoreInfo* ScoreMsg::mutable_score_info(int index) {
  // @@protoc_insertion_point(field_mutable:UNO.ScoreMsg.score_info)
  return score_info_.Mutable(index);
}
inline ::UNO::ScoreInfo* ScoreMsg::add_score_info() {
  // @@protoc_insertion_point(field_add:UNO.ScoreMsg.score_info)
  return score_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UNO::ScoreInfo >&
ScoreMsg::score_info() const {
  // @@protoc_insertion_point(field_list:UNO.ScoreMsg.score_info)
  return score_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::UNO::ScoreInfo >*
ScoreMsg::mutable_score_info() {
  // @@protoc_insertion_point(field_mutable_list:UNO.ScoreMsg.score_info)
  return &score_info_;
}

// -------------------------------------------------------------------

// UNOMsg

// required .UNO.UNOMsg.Type type = 1;
inline bool UNOMsg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UNOMsg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UNOMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UNOMsg::clear_type() {
  type_ = 91;
  clear_has_type();
}
inline ::UNO::UNOMsg_Type UNOMsg::type() const {
  // @@protoc_insertion_point(field_get:UNO.UNOMsg.type)
  return static_cast< ::UNO::UNOMsg_Type >(type_);
}
inline void UNOMsg::set_type(::UNO::UNOMsg_Type value) {
  assert(::UNO::UNOMsg_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:UNO.UNOMsg.type)
}

// required int64 sequence = 2;
inline bool UNOMsg::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UNOMsg::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UNOMsg::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UNOMsg::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 UNOMsg::sequence() const {
  // @@protoc_insertion_point(field_get:UNO.UNOMsg.sequence)
  return sequence_;
}
inline void UNOMsg::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:UNO.UNOMsg.sequence)
}

// optional .UNO.RoomMsg room_msg = 3;
inline bool UNOMsg::has_room_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UNOMsg::set_has_room_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UNOMsg::clear_has_room_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UNOMsg::clear_room_msg() {
  if (room_msg_ != NULL) room_msg_->::UNO::RoomMsg::Clear();
  clear_has_room_msg();
}
inline const ::UNO::RoomMsg& UNOMsg::room_msg() const {
  // @@protoc_insertion_point(field_get:UNO.UNOMsg.room_msg)
  return room_msg_ != NULL ? *room_msg_ : *default_instance_->room_msg_;
}
inline ::UNO::RoomMsg* UNOMsg::mutable_room_msg() {
  set_has_room_msg();
  if (room_msg_ == NULL) room_msg_ = new ::UNO::RoomMsg;
  // @@protoc_insertion_point(field_mutable:UNO.UNOMsg.room_msg)
  return room_msg_;
}
inline ::UNO::RoomMsg* UNOMsg::release_room_msg() {
  clear_has_room_msg();
  ::UNO::RoomMsg* temp = room_msg_;
  room_msg_ = NULL;
  return temp;
}
inline void UNOMsg::set_allocated_room_msg(::UNO::RoomMsg* room_msg) {
  delete room_msg_;
  room_msg_ = room_msg;
  if (room_msg) {
    set_has_room_msg();
  } else {
    clear_has_room_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.UNOMsg.room_msg)
}

// optional .UNO.GameMsg game_msg = 4;
inline bool UNOMsg::has_game_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UNOMsg::set_has_game_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UNOMsg::clear_has_game_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UNOMsg::clear_game_msg() {
  if (game_msg_ != NULL) game_msg_->::UNO::GameMsg::Clear();
  clear_has_game_msg();
}
inline const ::UNO::GameMsg& UNOMsg::game_msg() const {
  // @@protoc_insertion_point(field_get:UNO.UNOMsg.game_msg)
  return game_msg_ != NULL ? *game_msg_ : *default_instance_->game_msg_;
}
inline ::UNO::GameMsg* UNOMsg::mutable_game_msg() {
  set_has_game_msg();
  if (game_msg_ == NULL) game_msg_ = new ::UNO::GameMsg;
  // @@protoc_insertion_point(field_mutable:UNO.UNOMsg.game_msg)
  return game_msg_;
}
inline ::UNO::GameMsg* UNOMsg::release_game_msg() {
  clear_has_game_msg();
  ::UNO::GameMsg* temp = game_msg_;
  game_msg_ = NULL;
  return temp;
}
inline void UNOMsg::set_allocated_game_msg(::UNO::GameMsg* game_msg) {
  delete game_msg_;
  game_msg_ = game_msg;
  if (game_msg) {
    set_has_game_msg();
  } else {
    clear_has_game_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.UNOMsg.game_msg)
}

// optional .UNO.ChatMsg chat_msg = 5;
inline bool UNOMsg::has_chat_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UNOMsg::set_has_chat_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UNOMsg::clear_has_chat_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UNOMsg::clear_chat_msg() {
  if (chat_msg_ != NULL) chat_msg_->::UNO::ChatMsg::Clear();
  clear_has_chat_msg();
}
inline const ::UNO::ChatMsg& UNOMsg::chat_msg() const {
  // @@protoc_insertion_point(field_get:UNO.UNOMsg.chat_msg)
  return chat_msg_ != NULL ? *chat_msg_ : *default_instance_->chat_msg_;
}
inline ::UNO::ChatMsg* UNOMsg::mutable_chat_msg() {
  set_has_chat_msg();
  if (chat_msg_ == NULL) chat_msg_ = new ::UNO::ChatMsg;
  // @@protoc_insertion_point(field_mutable:UNO.UNOMsg.chat_msg)
  return chat_msg_;
}
inline ::UNO::ChatMsg* UNOMsg::release_chat_msg() {
  clear_has_chat_msg();
  ::UNO::ChatMsg* temp = chat_msg_;
  chat_msg_ = NULL;
  return temp;
}
inline void UNOMsg::set_allocated_chat_msg(::UNO::ChatMsg* chat_msg) {
  delete chat_msg_;
  chat_msg_ = chat_msg;
  if (chat_msg) {
    set_has_chat_msg();
  } else {
    clear_has_chat_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.UNOMsg.chat_msg)
}

// optional string error_msg = 6;
inline bool UNOMsg::has_error_msg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UNOMsg::set_has_error_msg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UNOMsg::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UNOMsg::clear_error_msg() {
  if (error_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_msg_->clear();
  }
  clear_has_error_msg();
}
inline const ::std::string& UNOMsg::error_msg() const {
  // @@protoc_insertion_point(field_get:UNO.UNOMsg.error_msg)
  return *error_msg_;
}
inline void UNOMsg::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
  // @@protoc_insertion_point(field_set:UNO.UNOMsg.error_msg)
}
inline void UNOMsg::set_error_msg(const char* value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:UNO.UNOMsg.error_msg)
}
inline void UNOMsg::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UNO.UNOMsg.error_msg)
}
inline ::std::string* UNOMsg::mutable_error_msg() {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UNO.UNOMsg.error_msg)
  return error_msg_;
}
inline ::std::string* UNOMsg::release_error_msg() {
  clear_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_msg_;
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UNOMsg::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_msg_;
  }
  if (error_msg) {
    set_has_error_msg();
    error_msg_ = error_msg;
  } else {
    clear_has_error_msg();
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.UNOMsg.error_msg)
}

// optional .UNO.ScoreMsg score_msg = 7;
inline bool UNOMsg::has_score_msg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UNOMsg::set_has_score_msg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UNOMsg::clear_has_score_msg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UNOMsg::clear_score_msg() {
  if (score_msg_ != NULL) score_msg_->::UNO::ScoreMsg::Clear();
  clear_has_score_msg();
}
inline const ::UNO::ScoreMsg& UNOMsg::score_msg() const {
  // @@protoc_insertion_point(field_get:UNO.UNOMsg.score_msg)
  return score_msg_ != NULL ? *score_msg_ : *default_instance_->score_msg_;
}
inline ::UNO::ScoreMsg* UNOMsg::mutable_score_msg() {
  set_has_score_msg();
  if (score_msg_ == NULL) score_msg_ = new ::UNO::ScoreMsg;
  // @@protoc_insertion_point(field_mutable:UNO.UNOMsg.score_msg)
  return score_msg_;
}
inline ::UNO::ScoreMsg* UNOMsg::release_score_msg() {
  clear_has_score_msg();
  ::UNO::ScoreMsg* temp = score_msg_;
  score_msg_ = NULL;
  return temp;
}
inline void UNOMsg::set_allocated_score_msg(::UNO::ScoreMsg* score_msg) {
  delete score_msg_;
  score_msg_ = score_msg;
  if (score_msg) {
    set_has_score_msg();
  } else {
    clear_has_score_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:UNO.UNOMsg.score_msg)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace UNO

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::UNO::RoomDetail_RoomState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UNO::RoomDetail_RoomState>() {
  return ::UNO::RoomDetail_RoomState_descriptor();
}
template <> struct is_proto_enum< ::UNO::UserInfo_State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UNO::UserInfo_State>() {
  return ::UNO::UserInfo_State_descriptor();
}
template <> struct is_proto_enum< ::UNO::StatusInfo_StatusType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UNO::StatusInfo_StatusType>() {
  return ::UNO::StatusInfo_StatusType_descriptor();
}
template <> struct is_proto_enum< ::UNO::RoomMsg_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UNO::RoomMsg_Type>() {
  return ::UNO::RoomMsg_Type_descriptor();
}
template <> struct is_proto_enum< ::UNO::GameMsg_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UNO::GameMsg_Type>() {
  return ::UNO::GameMsg_Type_descriptor();
}
template <> struct is_proto_enum< ::UNO::GameMsg_ColorInfo> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UNO::GameMsg_ColorInfo>() {
  return ::UNO::GameMsg_ColorInfo_descriptor();
}
template <> struct is_proto_enum< ::UNO::UNOMsg_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UNO::UNOMsg_Type>() {
  return ::UNO::UNOMsg_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_treadstone_2eproto__INCLUDED
